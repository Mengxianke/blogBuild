import{_ as e,c as a,aO as d,o as r}from"./chunks/framework.DEWO2zTc.js";const i="/blogBuild/jsWaitTask.png",o="/blogBuild/jsEventLoop.png",l="/blogBuild/jsEventLoop2.png",g=JSON.parse('{"title":"js单线程","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/jsFundation/promise/overview/index.md","filePath":"knowledge/jsFundation/promise/overview/index.md"}'),n={name:"knowledge/jsFundation/promise/overview/index.md"};function s(h,t,c,p,m,u){return r(),a("div",null,t[0]||(t[0]=[d('<h1 id="js单线程" tabindex="-1">js单线程 <a class="header-anchor" href="#js单线程" aria-label="Permalink to &quot;js单线程&quot;">​</a></h1><p>如果没有特殊处理，JS引擎在执行异步任务时，应该是存在等待的，不去做任何其他事情。用一个图来展示这个过程，可以看出，在执行异步任务时有大量的空闲时间被浪费。 <img src="'+i+'" alt="An image"> 当引擎忙于耗费 CPU 资源的任务时候，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。</p><p>因此, js单线程的特点为如下两点:</p><ol><li><p>单线程 意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。</p></li><li><p>非阻塞 则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p></li></ol><h1 id="宏任务与微任务" tabindex="-1">宏任务与微任务 <a class="header-anchor" href="#宏任务与微任务" aria-label="Permalink to &quot;宏任务与微任务&quot;">​</a></h1><h2 id="宏任务" tabindex="-1">宏任务 <a class="header-anchor" href="#宏任务" aria-label="Permalink to &quot;宏任务&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>I/O</td><td>✅</td><td>✅</td></tr><tr><td>setTimeout</td><td>✅</td><td>✅</td></tr><tr><td>setInterval</td><td>✅</td><td>✅</td></tr><tr><td>setImmediate</td><td>❌</td><td>✅</td></tr><tr><td>requestAnimationFrame</td><td>✅</td><td>❌</td></tr></tbody></table><h2 id="微任务" tabindex="-1">微任务 <a class="header-anchor" href="#微任务" aria-label="Permalink to &quot;微任务&quot;">​</a></h2><table tabindex="0"><thead><tr><th>#</th><th>浏览器</th><th>Node</th></tr></thead><tbody><tr><td>process.nextTick</td><td>❌</td><td>✅</td></tr><tr><td>MutationObserver</td><td>✅</td><td>❌</td></tr><tr><td>Promise.then catch finally</td><td>✅</td><td>✅</td></tr></tbody></table><h2 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><p><img src="'+o+'" alt="An image"><img src="'+l+'" alt="An image"></p><ol><li>进入到script标签,就进入到了第一次事件循环.</li><li>遇到同步代码，立即执行</li><li>遇到宏任务,放入到宏任务队列里.</li><li>遇到微任务,放入到微任务队列里.</li><li>执行完所有同步代码</li><li>执行微任务代码</li><li>微任务代码执行完毕，本次队列清空</li><li>寻找下一个宏任务，重复步骤1 以此反复直到清空所以宏任务，这种不断重复的执行机制，就叫做事件循环 微任务比宏任务执行要早。宏任务里如果有宏任务，不会执行里面的那个宏任务，而是被丢进任务队列后面，所以会最后执行。</li></ol><h1 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h1><ol><li><a href="https://cloud.tencent.com/developer/article/2062302" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/2062302</a></li><li>详解宏任务、微任务与事件循环 Event Loop <a href="https://juejin.cn/post/7020710294083092493" target="_blank" rel="noreferrer">https://juejin.cn/post/7020710294083092493</a></li></ol>',14)]))}const f=e(n,[["render",s]]);export{g as __pageData,f as default};
