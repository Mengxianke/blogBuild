import{_ as a,c as d,aO as r,o}from"./chunks/framework.DEWO2zTc.js";const b=JSON.parse('{"title":"打包构建流程","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/ModuleSystem/webpack/build/index.md","filePath":"knowledge/ModuleSystem/webpack/build/index.md"}'),n={name:"knowledge/ModuleSystem/webpack/build/index.md"};function t(l,e,u,i,c,p){return o(),d("div",null,e[0]||(e[0]=[r('<h1 id="打包构建流程" tabindex="-1">打包构建流程 <a class="header-anchor" href="#打包构建流程" aria-label="Permalink to &quot;打包构建流程&quot;">​</a></h1><p>EntryPlugin将webpack配置文件中的entry转换为依赖，并调用compilation类的addEntry方法生成初始化的ModuleTree<br> 执行_factorizeModule，根据依赖的类型，通过模块工厂(Module Factory)创建出模块(Module)<br> 执行_addModule, 存储Module<br> 执行_buildModule，开始构建<br> 执行loader, 将不同类型的文件转换成webpack能够解析的javascript文件<br> 调用acorn的parse方法将js代码解析为抽象语法树<br> 遇到import语句时，调用当前模块的addDependency方法，给模块添加其依赖。<br> 给Module模块添加依赖完毕后，执行处理各个模块依赖的函数_processModuleDependencies， 遍历依赖，返回到流程2，递归进行构建。<br> 所有依赖都解析完毕后，生成Module Grpah, 模块间的依赖图。</p><p>之后根据模块间的依赖图，生成Chunk Graph。 为每一个Entry都生成一个Chunk. 根据依赖图，遍历模块，根据依赖关系， 将模块放入到相应的Chunk中。如果Module模块是动态导入的，根据这个Module在生成一个Chunk。 重复上述过程直到生成所有的Chunk。<br> 至此编译阶段完毕。<br> 产出阶段: 根据根据构建的Chunk图，生成最终文件。 模板hash更新，模板渲染chunk, 生成bundle文件。</p>',3)]))}const h=a(n,[["render",t]]);export{b as __pageData,h as default};
