import{_ as l,c as i,aO as e,o as t}from"./chunks/framework.DEWO2zTc.js";const o="/blogBuild/network/transportLayer.png",r="/blogBuild/network/UDP_Header.png",n="/blogBuild/network/TCP_Header.png",h="/blogBuild/network/TCP_Window.png",s="/blogBuild/network/TCP_TimeOut_Retry2.png",d="/blogBuild/network/TCP_Window2.png",p="/blogBuild/network/TCPSegment.png",c="/blogBuild/network/TCP_TimeOut_Retry1.png",P="/blogBuild/network/TCP_Quick_Retry.png",m="/blogBuild/network/networkLayer.png",u="/blogBuild/network/IP.png",C="/blogBuild/network/IPAddress.png",g="/blogBuild/network/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png",T="/blogBuild/network/router.png",x=JSON.parse('{"title":"七层网络模型","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/network/OSIModel/index.md","filePath":"knowledge/network/OSIModel/index.md"}'),b={name:"knowledge/network/OSIModel/index.md"};function A(_,a,k,q,f,w){return t(),i("div",null,a[0]||(a[0]=[e('<h1 id="七层网络模型" tabindex="-1">七层网络模型 <a class="header-anchor" href="#七层网络模型" aria-label="Permalink to &quot;七层网络模型&quot;">​</a></h1><h1 id="tcp-ip-网络模型" tabindex="-1">TCP/IP 网络模型 <a class="header-anchor" href="#tcp-ip-网络模型" aria-label="Permalink to &quot;TCP/IP 网络模型&quot;">​</a></h1><h2 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h2><h2 id="传输层" tabindex="-1">传输层 <a class="header-anchor" href="#传输层" aria-label="Permalink to &quot;传输层&quot;">​</a></h2><p><img src="'+o+'" alt="An image"></p><h3 id="传输协议" tabindex="-1">传输协议 <a class="header-anchor" href="#传输协议" aria-label="Permalink to &quot;传输协议&quot;">​</a></h3><h4 id="udp结构" tabindex="-1">UDP结构 <a class="header-anchor" href="#udp结构" aria-label="Permalink to &quot;UDP结构&quot;">​</a></h4><p><img src="'+r+'" alt="An image"></p><ol><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ol><h4 id="tcp结构" tabindex="-1">TCP结构 <a class="header-anchor" href="#tcp结构" aria-label="Permalink to &quot;TCP结构&quot;">​</a></h4><p><img src="'+n+'" alt="An image"></p><ol><li>标和源端口：主要是告诉 TCP 协议应该把报文发给哪个进程。</li><li>序列号：每发送一次数据，累加一次。</li><li>确认应答号:</li><li>控制位：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号, 以前的数据都已经被正常接收。用来解决丢包的问题。 TCP 序列号(Seq)和确认号(ACK)的变化规则: 发送的TCP报文(以客户端/服务端视角): 序列号(seq) = 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。 确认号(ACK) = 上一次收到的报文中的序列号 + len（数据长度）。 特殊情况，如果收到的是 SYN报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</li></ol><h4 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to &quot;滑动窗口&quot;">​</a></h4><p>TCP为了达到有序性，每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了，再发送下一个。 如果一个TCP段(Segment), 接着另一个TCP段传输，数据包的往返时间越长，通信的效率就越低。TCP引入窗口概念，即使在往返时间较长的情况下，它也不会降低网络通信的效率。 <img src="'+h+'" alt="An image"> 如上图窗口所示:</p><ol><li>0 - 4的TCP分段已经发送，客户端并接收到ACK应答。</li><li>在窗口中， 一部分是已发送但未确认，这部分可能在网络中丢失，数据必须保留以便必要时重传， 另一部分表示，未发送但可发送，这部分接收方缓冲区还有空间保存，可以发出去；</li><li>最后的部分代表，未发送且暂不可发送，这部分已超出接收方缓冲区存储空间，就算发出去也没意义； 下图表示一系列，客户端向服务端发送数据的过程: <img src="'+s+'" alt="An image"></li><li>应用程序读取数据，从缓冲区移除后， 客户端接收到ACK应答， 接收方通告新窗口大小为 15 字节，窗口左边缘向右移动。 <img src="'+d+'" alt="An image"></li><li>发送方的数据2(序列号从10，长度为4)，为已发送，但待确认。数据3(序列号14, 长度为4)这部分接收方缓冲区还有空间，可以发出</li><li>当数据3发送至服务端时， ACK累计为10, 代表前10个TCP分段已经接收，但从第11个分段开始，服务端没有接收到数据包。因此判断丢包。</li><li>向客户端发起ACK应答报，提示客户端丢包现象存现。客户端重新发送序列号从10开始的，长度为4的字节。</li><li>数据2到达， 接收方将其保存在缓冲区中，并回复 ACK</li><li>数据2， 数据3组成连续数据，可以提交给应用程序读取。</li></ol><h3 id="tcp与udp的差别" tabindex="-1">TCP与UDP的差别 <a class="header-anchor" href="#tcp与udp的差别" aria-label="Permalink to &quot;TCP与UDP的差别&quot;">​</a></h3><h4 id="tcp建立链接与断开连接" tabindex="-1">TCP建立链接与断开连接 <a class="header-anchor" href="#tcp建立链接与断开连接" aria-label="Permalink to &quot;TCP建立链接与断开连接&quot;">​</a></h4><p>三次握手:</p><ol><li>一开始，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。</li><li>然后客户端主动发送SYN报文，报文中包含初始化序列号(seq)给服务端.</li><li>服务端收到后: 给客户端返回一个ACK报文。报文中包含一个序列号(seq)，和确认应答号(ACK) 。证明服务端能够正常接受客户端</li><li>客户端接收到服务端的ACK报文后, 发送一个ACK报文。 报文中包含对服务端发送的序列号确认的应答号, 证明客户端有接受的能力。</li><li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。 三次握手目的是保证双方都有发送和接收的能力。</li></ol><p>四次挥手:</p><ol><li>客户端主动调用关闭, 发送 FIN 报文, 这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态。客户端不再发送数据了但是还能接收数据(shuntdown关闭)。</li><li>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文， 此时服务端进入 CLOSE_WAIT 状态。TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中。在此状态，服务端可能会继续传输数据。服务端知道客户端不再发送数据，但此时还有数据要发送，不能马上发送FIN报文。将发送 FIN 报文的控制权交给服务端应用程序。 多一次挥手。</li><li>接着，当服务端在读取缓冲区数据的时候, 读取到结束标志，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数。这时服务端就会发一个 FIN包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</li><li>客户端接收到服务端的 FIN 包， 并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li><li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li><li>客户端经过 2MSL(MSL Maximum Segment Lifetime -- 报文最大生存时间) 时间之后，也进入 CLOSE 状态；2MSL等待, 确保服务端正常关闭，服务器如果接收不到ACK应答, 重传报文。确保第四步，服务端正常接收到ACK报文。</li></ol><p>总结: 为何断开链接比建立链接多一次挥手?</p><p>ACK报文是否可以和FIN报文一起发送? 服务端决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，所以服务端的 ACK 和 FIN 一般都会分开发送。</p><p>发送FIN报文的时机是什么? FIN报文发送时机，</p><ol><li>调用关闭连接的函数</li><li>非正常退出应用程序，发送FIN报文。 关闭连接的函数，其实关闭的连接的函数有两种函数</li><li>close函数</li><li>shutdown函数</li></ol><p>四次挥手中乱序FIN包如何处理?</p><h4 id="tcp面向字节流协议-udp为面向报文协议" tabindex="-1">TCP面向字节流协议，UDP为面向报文协议 <a class="header-anchor" href="#tcp面向字节流协议-udp为面向报文协议" aria-label="Permalink to &quot;TCP面向字节流协议，UDP为面向报文协议&quot;">​</a></h4><p>UDP面向报文协议: 当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分, 在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息。 操作系统在收到 UDP 报文后，会将其插入到队列里，队列里的每一个元素就是一个 UDP 报文。从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p><p>TCP面向字节流协议: <img src="'+p+'" alt="An image"> 当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。因此，我们不能认为一个用户消息对应一个 TCP 报文, 正因为这样，所以 TCP 是面向字节流的协议。</p><h4 id="tcp可靠-udp不可靠" tabindex="-1">TCP可靠, UDP不可靠 <a class="header-anchor" href="#tcp可靠-udp不可靠" aria-label="Permalink to &quot;TCP可靠, UDP不可靠&quot;">​</a></h4><p>TCP可靠性体现在:</p><ol><li>不丢失</li><li>不重复</li><li>按序到达</li></ol><p>TCP为达到可靠性，引入如下机制:</p><ol><li>可靠传入机制, 通过序列号与确认应答。 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</li><li>TCP重传机制 2.1 超时重传 <img src="'+c+'" alt="An image"> 发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的ACK 确认应答报文，就会重发该数据。 如何确定超时时间? RTO(超时重传时间) &gt;(略大于) RTT(数据发送时刻到接收到确认的时刻的差值). linux计算RTO: 如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍。 尚未解决问题:</li><li>超时周期可能相对较长, 需要通过快速重传机制来解决超时重发的时间等待。</li><li>因不知道具体滑动窗口中，哪一个数据包丢失，因此需要重传滑动窗口中所有的数据包。 2.2 快速重传 <img src="'+P+'" alt="An image"> 快速重传不依赖定时器的超时，而是依靠基于接收端的反馈信息来引发重传(ACK确认包来进行重传)。 如图所见，服务端没有收到序列号为5的TCP数据包，就收到了序列号为6的数据包，发生乱序现象。与超时重试不同(延时发送)，服务端立即回复ACK报文(ACK的值为当前累计的值)。 通过重复传递相同ACK报文，客户端发现有丢包现象存在，重新发送数据包。 尚未解决问题:</li><li>因不知道具体滑动窗口中，哪一个数据包丢失，因此需要重传滑动窗口中所有的数据包。 2.3 SACK 为了解决超时重传和快速重传的遗留问题，引入SACK重传机制。 TCP 头部字段里加一个 SACK， 它可以将已收到的数据的信息发送给服务端，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知知道了这些信息，就可以只重传丢失的数据。</li></ol><h2 id="_2-4-d-sack" tabindex="-1">2.4 D-SACK <a class="header-anchor" href="#_2-4-d-sack" aria-label="Permalink to &quot;2.4 D-SACK&quot;">​</a></h2><h4 id="tcp流量控制-拥塞机制-udp没有" tabindex="-1">TCP流量控制，拥塞机制， UDP没有 <a class="header-anchor" href="#tcp流量控制-拥塞机制-udp没有" aria-label="Permalink to &quot;TCP流量控制，拥塞机制， UDP没有&quot;">​</a></h4><h4 id="tcp和udp的应用场景" tabindex="-1">TCP和UDP的应用场景 <a class="header-anchor" href="#tcp和udp的应用场景" aria-label="Permalink to &quot;TCP和UDP的应用场景&quot;">​</a></h4><p>TCP的应用场景</p><ol><li>文件传输</li><li>HTTP / HTTPS UDP的应用场景</li><li>包总量较少的通信, 如 DNS 、SNMP 等;</li><li>视频、音频等多媒体通信；</li><li>广播通信;</li></ol><h2 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h2><p><img src="'+m+'" alt="An image"></p><h3 id="ip协议-internet-protocol" tabindex="-1">IP协议 Internet Protocol <a class="header-anchor" href="#ip协议-internet-protocol" aria-label="Permalink to &quot;IP协议 Internet Protocol&quot;">​</a></h3><p><img src="'+u+'" alt="An image"></p><h3 id="寻址" tabindex="-1">寻址 <a class="header-anchor" href="#寻址" aria-label="Permalink to &quot;寻址&quot;">​</a></h3><h4 id="ip地址" tabindex="-1">IP地址 <a class="header-anchor" href="#ip地址" aria-label="Permalink to &quot;IP地址&quot;">​</a></h4><p><img src="'+C+'" alt="An image"><img src="'+g+'" alt="An image"></p><h4 id="路由" tabindex="-1">路由 <a class="header-anchor" href="#路由" aria-label="Permalink to &quot;路由&quot;">​</a></h4><p><img src="'+T+'" alt="An image"></p><h2 id="网路接口" tabindex="-1">网路接口 <a class="header-anchor" href="#网路接口" aria-label="Permalink to &quot;网路接口&quot;">​</a></h2><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h1><ol><li>图解网络: <a href="https://xiaolincoding.com/network/" target="_blank" rel="noreferrer">https://xiaolincoding.com/network/</a></li><li>TCP快速重传机制：<a href="https://www.cnblogs.com/lshs/p/6038547.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/lshs/p/6038547.html</a></li><li>重传机制: <a href="https://zhuanlan.zhihu.com/p/101702312" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/101702312</a></li><li>TCP的流量控制: <a href="https://fasionchan.com/network/tcp/sliding-window/" target="_blank" rel="noreferrer">https://fasionchan.com/network/tcp/sliding-window/</a></li></ol>',51)]))}const D=l(b,[["render",A]]);export{x as __pageData,D as default};
