import{_ as t,c as e,aO as r,o as n}from"./chunks/framework.DEWO2zTc.js";const o="/blogBuild/network/http2Concurrent.png",i="/blogBuild/network/http2Stream.png",l="/blogBuild/network/frameStructure.png",h="/blogBuild/network/staticDic.png",s="/blogBuild/network/http2Header.png",d="/blogBuild/network/huffman.png",k=JSON.parse('{"title":"http1.0","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/network/httpVersion/index.md","filePath":"knowledge/network/httpVersion/index.md"}'),m={name:"knowledge/network/httpVersion/index.md"};function p(c,a,u,g,f,b){return n(),e("div",null,a[0]||(a[0]=[r('<h1 id="http1-0" tabindex="-1">http1.0 <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;http1.0&quot;">​</a></h1><h1 id="http2-0" tabindex="-1">http2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;http2.0&quot;">​</a></h1><h2 id="并发传输" tabindex="-1">并发传输 <a class="header-anchor" href="#并发传输" aria-label="Permalink to &quot;并发传输&quot;">​</a></h2><p><img src="'+o+'" alt="An image"> 多个Stream，复用一个TCP链接。解决队头阻塞问题。提高HTTP吞吐量。 1个TCP链接包含一个或者多个Stream。不同Stream的帧是可以乱序发送。但每一帧 的头部都会携带StreamID, 所以接收端可以通过StreamID有序组装成HTTP消息。同一Stream内部的帧必须严格有序。</p><h3 id="stream-流" tabindex="-1">Stream(流) <a class="header-anchor" href="#stream-流" aria-label="Permalink to &quot;Stream(流)&quot;">​</a></h3><p><img src="'+i+'" alt="An image"> 一个Stream种包含1个或多个Message, Message对应请求或者响应。</p><h4 id="二进制帧" tabindex="-1">二进制帧 <a class="header-anchor" href="#二进制帧" aria-label="Permalink to &quot;二进制帧&quot;">​</a></h4><p>Message里边包含一个或多个Frame, Frame以二进制压缩格式存放头部和包体。 <img src="'+l+'" alt="An image"> 帧头就只有9个字节，帧长度最后一个字节代表帧类型，一般分为数据帧和控制帧。<br> HTTP/2把响应报文分成HEADERS(首部)帧，和DATA(消息负载) 帧头最后四个字节是流标识符(Stream ID) 帧数据是存放通过HPACK算法压缩过的HTTP头部和包体。</p><h5 id="首部-header-帧" tabindex="-1">首部(Header)帧 <a class="header-anchor" href="#首部-header-帧" aria-label="Permalink to &quot;首部(Header)帧&quot;">​</a></h5><p>头部压缩, 采用HPACK算法，HPACK算法主要包括三个组成部分:</p><ol><li>静态字典 <img src="'+h+'" alt="An image"> HTTP头部结构: <img src="'+s+'" alt="An image"></li></ol><p>server: nghttpx\\r\\n<br> HTTP1.1占用17个字节, 每一个单词采用ASCII编码为1个字节(8bit), HTTP2.0,压缩成8个字节。 <img src="'+d+'" alt="An image"> a. 如果字头属于静态范围，并且Value变化，HTTP/2头部前两位规定为0，1 b. 从静态表中找到头部字段server, Index: 54, 第一个字节: 01110110. c. 第二个字节首位bit位，表示Value是否经过huffman编码， 剩余7位表示Value的长度。 首位1代表已经Huffman编码，后边0000110代表6个字节，为ValueS的长度为6个字节。 d. 第三个字节为经过huffman编码的valueString, nghttpx =&gt; [.........],[.........],[.........],[.........],[.........],[.........] (6个字节) 2. 动态字典 静态表只包含61种高频出现在头部的字符串， 不在静态表范围内的头部字符串，建立动态表。Index从62起步， 编码解码的时候随时更新。<br> 头部[User-Agent], 经过Huffman编码，客户端和服务器双方更新动态表，添加index: 62. 下次只用发一个字节的index号，双方动态获取字段数据。 3. Huffman编码 HTTP/2根据出现频率将ASCII编码为了Huffman编码，</p><h5 id="消息负载-data" tabindex="-1">消息负载(Data) <a class="header-anchor" href="#消息负载-data" aria-label="Permalink to &quot;消息负载(Data)&quot;">​</a></h5><p>帧类型: DATA, 传递HTTP包体。</p><h2 id="服务器主动推送资源" tabindex="-1">服务器主动推送资源 <a class="header-anchor" href="#服务器主动推送资源" aria-label="Permalink to &quot;服务器主动推送资源&quot;">​</a></h2><h1 id="http3-0" tabindex="-1">http3.0 <a class="header-anchor" href="#http3-0" aria-label="Permalink to &quot;http3.0&quot;">​</a></h1><p>参考:</p><ol><li><a href="https://xiaolincoding.com/" target="_blank" rel="noreferrer">https://xiaolincoding.com/</a></li></ol>',18)]))}const x=t(m,[["render",p]]);export{k as __pageData,x as default};
