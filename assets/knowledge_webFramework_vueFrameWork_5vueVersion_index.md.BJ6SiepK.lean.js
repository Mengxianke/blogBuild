import{_ as a,c as i,aO as s,o as n}from"./chunks/framework.DEWO2zTc.js";const c=JSON.parse('{"title":"Vue2与Vue3","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/webFramework/vueFrameWork/5vueVersion/index.md","filePath":"knowledge/webFramework/vueFrameWork/5vueVersion/index.md"}'),t={name:"knowledge/webFramework/vueFrameWork/5vueVersion/index.md"};function l(o,e,r,u,h,p){return n(),i("div",null,e[0]||(e[0]=[s(`<h1 id="vue2与vue3" tabindex="-1">Vue2与Vue3 <a class="header-anchor" href="#vue2与vue3" aria-label="Permalink to &quot;Vue2与Vue3&quot;">​</a></h1><p>Vue2与Vue3的对比</p><h2 id="响应式数据的定义" tabindex="-1">响应式数据的定义 <a class="header-anchor" href="#响应式数据的定义" aria-label="Permalink to &quot;响应式数据的定义&quot;">​</a></h2><h3 id="vue2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><p>Vuew2采用Object.defineProperty，定义响应式变量。其有如下局限性:</p><ol><li>Vue2定义响应式变量的时机在组件初始化initState的时候。 因此Object.defineProperty不能拦截属性的添加，和删除操作。</li><li>Vue2无法直接监听数组元素引起的改变或者数组长度的改变，Vue通过重写了数组的push, pop, shift, unshift, splice, sort, reverse来间接实现数组的变化的监听。</li><li>为了能够达到深度监听，对嵌套属性定义响应式，需要递归遍历, 性能有损耗</li></ol><h3 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><p>Vue3为了解决解决Vue2在定义响应式变量中出现的问题，采用了ES6的Proxy做拦截的特性。Proxy的优势如下:</p><ol><li>Proxy 能拦截多达 13 种不同的对象操作，包括属性的读取、设置、枚举、删除等。</li><li>Proxy 可以轻松地监测到对象结构的任何变化，包括属性的添加和删除。</li></ol><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><h3 id="vue2-1" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2-1" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><ol><li>创建阶段: beforeCreated, created</li><li>挂载阶段: beforeMount, mounted</li><li>更新阶段: beforeUpdate, updated</li><li>销毁阶段: beforeDestory, destoryed</li></ol><h3 id="vue3-1" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3-1" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><ol><li>创建阶段: setup</li><li>挂载阶段: onBeforeMount, onMounted</li><li>更新阶段: onBeforeUpdate, onUpdated</li><li>销毁阶段: onBeforeUnmount, onUnmounted</li></ol><h2 id="api设计与组件选项" tabindex="-1">API设计与组件选项 <a class="header-anchor" href="#api设计与组件选项" aria-label="Permalink to &quot;API设计与组件选项&quot;">​</a></h2><h3 id="vue2-2" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2-2" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><p>Vue2采用的是Options API, 包含了data, methods，computed, watch Options Api的缺点:</p><ol><li>逻辑可能分散在各个选项中，导致代码的可读性和维护成本低</li></ol><h3 id="vue3-2" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3-2" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><ol><li>相关的的逻辑放在同一个函数中，使得代码更易于理解和维护。可以清晰地看到哪些数据和方法是属于某个特定功能。</li></ol><h2 id="vue2与vue3逻辑复用" tabindex="-1">Vue2与Vue3逻辑复用 <a class="header-anchor" href="#vue2与vue3逻辑复用" aria-label="Permalink to &quot;Vue2与Vue3逻辑复用&quot;">​</a></h2><p>Vue2与Vue3在逻辑复用上不相同。</p><h3 id="vue2-3" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2-3" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><p>Vue2使用Mixin混淆进行逻辑复用。 缺点命名冲突，</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import myMixin from &#39;./mixins/myMixin&#39;;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export default {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mixins: [myMixin],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="vue3-3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3-3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><p>Vue3使用组合式Composition API进行逻辑复用。 Composition API本质上通过函数的组合方式进行复用。 提取可复用的一段函数逻辑。</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 可复用的一段函数逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import { ref, onMounted } from &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">export function useCounter() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  const count = ref(0)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  const increment = () =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count.value++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  return { count, increment }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="diff算法" tabindex="-1">Diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;Diff算法&quot;">​</a></h2><p>Diff算法，对比两次虚拟DOM的不同，通过Diff算法，寻找 可复用的节点以及给原DOM打补丁。算法的设计是为了，经过最小次数的改动，从一个虚拟DOM树变化到另一个虚拟DOM树。 Diff算法采用的是深度优先，同层比较。<br><strong>同层比较:</strong><br> 如果两个节点对比后发现类型发生了变化，直接销毁该节点，将其替换为新节点。 否则认为其是一个可以复用的节点。 在销毁的过程中，其旧节点的子节点一并销毁。不会再参与到对比的流程中。</p><p><strong>深度优先:</strong><br> 如果发现节点是可以复用的，遍历其子节点，对子节点进行打补丁。对子节点进行打补丁后， 在对可复用的当前节点进行移动。</p><h3 id="vue2-4" tabindex="-1">Vue2 <a class="header-anchor" href="#vue2-4" aria-label="Permalink to &quot;Vue2&quot;">​</a></h3><p>双端比较，首尾四个指针，寻找可复用的节点。四个指针向内收缩。 当无可复用节点时，建立哈希表，通过哈希表找到对应的旧节点的位置，进行复用。 如果没有找到可复用的节点，需要创建节点。</p><p>双端比较算法，四个指针的作用是， 新节点序列中，左右指针的两侧节点表示旧节点序列中的相对应节点已经被复用。 明确复用节点，如何移动。</p><p>规则如下:</p><ol><li><strong>新旧节点的start节点可以复用</strong>。给这两个节点打补丁patchVNode, <strong>深度优先遍历，访问新旧节点。递归遍历结束后，指针同时右移动。</strong></li><li><strong>新旧节点的end节点可以复用</strong>。给这两个节点打补丁patchVNode, <strong>深度优先遍历。访问新旧节点。地递归遍历后，指针同时向左移动。</strong></li><li><strong>当旧节点的start和新节点end可复用</strong>。先深度优先，访问新旧节点。<strong>递归遍历后，移动旧节点(当前DOM节点)到旧节点的oldEnd后一个。 旧节点指针右移动，新节点指针左移动</strong></li><li><strong>当旧节点的end和新节点的start可复用</strong>。先深度优先，访问新旧节点。<strong>递归遍历后，移动旧节点到旧节点oldStart前一个。</strong></li></ol><h3 id="vue3-4" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3-4" aria-label="Permalink to &quot;Vue3&quot;">​</a></h3><p>Vue3采用最小递增子序</p>`,38)]))}const k=a(t,[["render",l]]);export{c as __pageData,k as default};
