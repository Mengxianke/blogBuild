import{_ as n,c as o,aO as a,o as t}from"./chunks/framework.DEWO2zTc.js";const u=JSON.parse('{"title":"组件抽象","description":"","frontmatter":{},"headers":[],"relativePath":"project/componentDesign/componentLogicReuse/index.md","filePath":"project/componentDesign/componentLogicReuse/index.md"}'),r={name:"project/componentDesign/componentLogicReuse/index.md"};function i(s,e,l,p,c,d){return t(),o("div",null,e[0]||(e[0]=[a('<h1 id="组件抽象" tabindex="-1">组件抽象 <a class="header-anchor" href="#组件抽象" aria-label="Permalink to &quot;组件抽象&quot;">​</a></h1><p>组件抽象是工程中绕不开的点， 它对代码逻辑复用起到了至关重要的作用。 因此，这个章节会回顾在项目中运用到的抽象的方法。</p><p>第一个是无头组件<code>Headless Component</code>, 组件难复用很多时候是因为不同的组件在UI呈现上会不同，但它们的逻辑共享。 这个时候，我们抽象出来的组件，需要将视图与业务逻辑进行分离。 将业务逻辑封装在了组件内部，通过框架<code>投影映射/插槽的</code>机制， 将业务逻辑中的上下文暴露给外侧，外侧获取到数据，负责如何呈现这部分数据，再将视图的部分&quot;投影&quot;进来进行渲染。</p><p>第二个是编程范式上, Angualr框架是基于OOP面向对象的思维，组件就是类。 React是函数式组件。组件就是函数。 Vue利用Mixin混合进行复用组件。因此，这些框架在复用代码，以及抽象的过程中， 使用到的方法论实则是面向对象和函数式编程的思想。 Angular通过继承的手段实现组件层面上的抽象， React是通过高阶函数对组件的行为进行扩展。</p><p>这些方法论并非是一种框架<strong>独有的产物</strong>, Angular, React都能实现HeadlessComponent, Angular与React也同样是<strong>多范式的框架</strong>。掌握它们的思想，灵活的运用才是目的。</p><h2 id="headless-component" tabindex="-1">Headless-Component <a class="header-anchor" href="#headless-component" aria-label="Permalink to &quot;Headless-Component&quot;">​</a></h2><p>Headless-Component是一种组件上的抽象 <a href="https://angular.love/headless-angular-components" target="_blank" rel="noreferrer">Headless Angular Components</a>，将视图与业务逻辑进行分离。对外只提供上下文，外侧负责渲染，最后将视图映射到组件内部中。</p><p>在B端的业务中，下拉框是运用比较多的组件，下拉框的内容在管理页面可以进行配置。 因此下拉框中每一项展示具有很强的灵活性。不同的业务场景对其展示也不同。 封装组件时候，将url传入组件，组件内封装获取列表的业务逻辑以及下拉框组件。 通过插槽的形式，将获取的数据通过上下文暴露给外侧的组件， 外侧的组件根据上下文进行绘制。可以根据这种方式进行一些扩展点的设计。</p><p>这种设计的好处是:</p><ol><li>高度定制化</li><li>灵活性和组合性</li><li>增强的可维护性</li><li>更小的包体积</li></ol><h2 id="继承-mixin" tabindex="-1">继承/Mixin <a class="header-anchor" href="#继承-mixin" aria-label="Permalink to &quot;继承/Mixin&quot;">​</a></h2><p>Mixin是Vue2的组件复用代码的形式， 继承是Angular框架组件复用代码的形式。 对于重复的逻辑，可以通过混合/继承的手段，进行复用代码。 抽出共享的逻辑，放入到一个Mixin中，后者放到一个基类中。</p>',12)]))}const h=n(r,[["render",i]]);export{u as __pageData,h as default};
